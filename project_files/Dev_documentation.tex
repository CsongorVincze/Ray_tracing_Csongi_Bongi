\documentclass{article}

% --- PACKAGES ---
\usepackage[utf8]{inputenc} % Allows standard characters
\usepackage{geometry}       % Adjusts page margins
\usepackage{listings}       % ESSENTIAL: Allows you to format code blocks
\usepackage{xcolor}         % Adds color support for the code blocks
\usepackage{hyperref}       % Makes the Table of Contents clickable

% --- CODE BLOCK STYLING ---
% This sets up how your code will look (like a dark theme editor)
\lstset{
    backgroundcolor=\color{black!5},   % Light grey background
    basicstyle=\ttfamily\small,        % Typewriter font
    breaklines=true,                   % Break long lines automatically
    frame=single,                      % Adds a frame around the code
    keywordstyle=\color{blue},         % Keywords (if/else) in blue
    commentstyle=\color{green!50!black}% Comments in dark green
}

% --- TITLE PAGE DATA ---
\title{Fejlesztői dokumentáció}
\author{Vincze Csongor}
\date{\today}

% --- DOCUMENT BEGINS HERE ---
\begin{document}


\maketitle

\tableofcontents
\newpage


\section{A program ismertetése, áttekintése}
Ez a program egy nagyon alapvető sugárkövetőt (ray tracer) implementál le.
A lényege, a virtuális kamerából (ahonnét mi a képet látjuk) sugarakat küld,
és ezeknek a sugaraknak a gömbökkel való ütközését követi.
Miután a felhasználó megadja a megfelelő paramétereket a program elkezdi a képkockák
generálását. A képkockák generálásának előrehaladását közben a felhasználó egy 
folyamatjelző sávon követheti. Amint az összes képkocka generálása megtörtént
a szoftver összefűzi a képkockákat egy videóvá, és ezt el is indítja.
A program és a hozzá tartózó dolgok elérhetőek a:
\url{https://github.com/CsongorVincze/Ray_tracing_Csongi_Bongi} linken.

\section{Nyelv, használt csomagok, kiegészítők}
A teljes projekt C nyelvben íródott, az alapvető C könyvtárak felhasználásával,
minden külső csomag nélkül. A program nagy vonalakban a \url{https://raytracing.github.io/books/RayTracingInOneWeekend.html#overview}
dokumentációt követi (természetesen C nyelvre átírva).

\section{Az architektúra áttekintése, a program kezelése}
A \texttt{video\_render.exe} fájlt megkaphatjuk ha 
egy mappába lementjük a letöltött \texttt{.c} és \texttt{.h} fájlokat és együtt lefordítjuk őket:
\begin{lstlisting}[language=bash]
gcc -o video_render.exe video_render.c vec_3.c sphere.c hittable.c hit_list.c render.c animation.c common.c color.c ray.c intervals.c -lm
\end{lstlisting}
Vagy egyszerűen futtasd a mellékelt \texttt{build.bat} fájlt.
(Esetlegesen lehet a Makefile-al is végezni ezt a folyamatot.)
A \texttt{video\_render.exe} futtatásakor a program bekéri a videó
elkészítéséhez szükséges adatokat. Ezek sorban:
\begin{enumerate}
    \item Milyen felbontást szeretnél? (szélesség pixelekben) (elfogadható értékek: $2^n$, ahol $n$ egész és $4 < n < 11$)
    \item Hány gömböt szeretnél? (ajánlott: 2-10)
    \item Milyen hosszú videót szeretnél? (a videó 30fps-en fut, 1-10 közötti egész szám elfogadott)
\end{enumerate}

Az első bemenet a kép vízszintes pixelszámát adja meg (a képarány 16:9). Itt 1024-nél már jelentősen
lelassul a program. 256-nál viszont még elég alacsony lesz a készített videó minősége.
Érdemes lehet ezt az értéket 512-re állítani. Ezzel az adattal a program
már el tudja készíteni az ún. nézőportált (viewport), ami meghatározza, hogy mit, hogy fogunk látni. A többi paraméter
fix. A \texttt{viewport\_creator()} függvény végzi ezt a folyamatot, és a \texttt{video\_render.c} hívja meg a \texttt{render.h}-ból.
A gömbök száma egészen 0-tól 50-ig terjedhet. Ennek ellenére nem ajánlott 10-nél
többet megadni mivel ez is jelentősen lelassítja a programot. A gömbökre van egy külön struktúra (sphere), egy ilyen tömböt hozunk
létre. A videó készítés közben mozgatni fogjuk a gömböket. Mivel csak gömb alakú objektumokkal dolgozunk,
így érdemes ennek a tömbnek az elejére egy előre beállított nagy gömböt rakni, hogy
legyen egy földünk a videókhoz. Így valójában egyel több gömbbel operálunk mint amennyit bekértünk.
A harmadik bekérésnél hasonló
okokból kiindulva 5 körüli értéket érdemes megadni. Mivel konstans 30 fps-el dolgozunk így csak simán visszaszámoljuk,
hogy hány képkockát kell legeneráljunk.


\section{Modulok és Fájlok}
A program mostantól moduláris felépítésű, azaz különválasztottuk a deklarációkat (header fájlok, .h) és az implementációkat (forrásfájlok, .c).
Ez a modern C fejlesztés szabványait követi, és lehetővé teszi a külön fordítást (separate compilation).
A fordítást egy \texttt{Makefile} vezérli.

    \subsection{Makefile}
    Ez a fájl tartalmazza a fordítási szabályokat. A \texttt{mingw32-make} (vagy \texttt{make}) parancs kiadásával automatikusan lefordulnak a módosított modulok, majd a linkelés után létrejön a \texttt{video\_render.exe}.

    \subsection{vec\_3 (vec\_3.h, vec\_3.c)}
    Mivel 3 dimenzióban dolgozunk szükségünk van vektoroperációkra.
    A header fájl tartalmazza a függvények prototípusait és a \texttt{vec\_3} struktúrát.
    Az implementáció a \texttt{.c} fájlban található. Ez biztosítja a műveleteket (összeadás, szorzás, dot product, stb.) és a random vektor generálást.

    \subsection{ray (ray.h, ray.c)}
    Ez a modul a sugár (ray) struktúrát és a sugárkövető függvényt (\texttt{\_pos()}) tartalmazza.

    \subsection{intervals (intervals.h, intervals.c)}
    Intervallumokkal végzett műveletek (tartalmazás vizsgálata). Segít az átláthatóságban, például a gömbök eltalálásakor.
    

    \subsection{sphere (sphere.h, sphere.c)}
    A gömb objektum megvalósítása.
    Ez a modul a gömb struktúrát hozza létre. A gömb egy középpontból és egy sugárból áll.
    Ezután a \texttt{hit\_sphere()} függvény következik ami, lényegében eldönti, hogy az adott sugár eltalálta-e az adott gömböt.
    Ez a függvény egy bináris értéket ad vissza. Emellett kiszámolja, hogy hol történt a találat, milyen hosszú
    volt a sugár, és a találatnál a gömb normálvektorát. Ezeket elmenti
    egy pointerrel inputként megadott \texttt{hit\_rec} struktúrába.
    Ezt két függvény követi; az \texttt{\_array\_spheres()} és a \texttt{\_rand\_spheres()}. Előbbi egy vízszintes sorba rak le gömböket.
    Ez inkább a teszteléshez, paraméterek állításához használandó.
    Útóbbi pedig (bizonyos korlátok kötött) random paraméterekkel rakja le a gömböket.

    \subsection{hittable (hittable.h, hittable.c)}
    Definiálja a \texttt{hit\_rec} struktúrát (találati rekord), a következő módon;

    \newpage
        \begin{lstlisting}[language=C]
        typedef struct{
            point_3 p;              // ebben taroljuk az eltalalt pontot
            vec_3 outward_normal;   // mindig kifele mutato norma
            vec_3 normal;           // ez a norma mindig a sugarral 
                                    // elenkezo iranyba mutat
            double t;               // mennyi "ido"-be telt a sugarnak 
                                    // eltalalni a pontot
            bool front_face;        // kivulrol jon-e a sugar
        } hit_rec;
        \end{lstlisting}

    Ezután tartalmazza a \texttt{hit\_side()} függvényt. A függvény lényege, hogy meghatározza,
    hogy a gömb melyik oldalán vagyunk. (A felhasználó által használt .exe fájl enélkül is
    működne mivel úgy vannak beállítva a paraméterek, hogy minden gömböt kívülről találjuk el.)

    \subsection{hit\_list (hit\_list.h, hit\_list.c)}
    Ez a modul egy függvényből áll, ez viszont egy nagyon hasznos függvény.
    A \texttt{which\_hit()} megnézi, hogy egy adott sugár melyik gömböket találja el
    (meghívja a \texttt{hit\_sphere()} függvényt minden gömbre), és a legközelebbi találat
    adatait lementi egy \texttt{hit\_rec} struktúrába. A függvény egyet ad vissza,
    ha sikerült eltalálni egy gömböt, nullát ha nem sikerült eltalálni semmit sem.

    \subsection{color.h}
    Először csinálunk egy color nevű típust ami egy hasommása a \texttt{vec\_3}
    stuktúrának. (Itt kihasználjuk azt, hogy egy RGB-vel megadott színnek pont három
    komponense van, csakúgy mint egy vektornak is.)
    Ez a fájl is egy függvényt tartalmaz. A \texttt{\_color\_divider()} inputként egy
    színt és egy fájl pointert kap. A színt szétbontja megfelelő RGB formátumra,
    és beleírja a fájlba.

    \subsection{common (common.h, common.c)}
    Általános segédfüggvények, például a program elején megjelenő felirat (\texttt{printCaption()}).

    \subsection{animation (animation.h, animation.c)}
    Az animációért felelős modul. Oszcilláció (\texttt{harm\_osc\_y()}) és véletlen mozgás (\texttt{random\_walk()}) implementációk.

    \subsection{render (render.h, render.c)}
    A renderelés magja. Itt először létrehozzuk a kamera és a nézőportál (viewport) paramétereit, a \texttt{viewport\_creator()}
    fügvénnyel. A fix képarányból és a kép szélességéből kiszámoljuk a 
    kép magasságát. Utána pedig a nézőportált (lényegileg a kiküldött sugaraknak ad egy korlátot
    hogy az egész térből mit lásson). Ezután kiszámoljuk a kis vektorokat amiket
    majd hozzáadogatunk a bal felső pixelhez, így jutunk el az összes pixelhez.
    Végül pedig kiszámoljuk a bal felső pixel (és a bal felső csúcs) koordinátáit.

    Ezután jön a \texttt{ray\_color()} függvény. Ez egy rekurzív függvény ami először
    megnézi hogy az adott irányba indított sugár talált-e (meghívja a \texttt{which\_hit()} függvényt).
    Ha volt találat akkor meghívja magát újra (a rekurziós szám 20-ra van állítva)
    a gömb találati pontjáról a gömbtől elfelé
    random irányba mutató irányvektorral (itt a \texttt{vec\_3}-ból hívja meg a 
    \texttt{\_unit\_vec\_on\_hemisphere()} függvényt), és a gömb adott pontjával
    (ezeket berakja egy \texttt{ray\_3} struktúrába), és végül a
    visszakapott értéket megszorozza a \texttt{reflection\_number}-rel (lényegében az, hogy
    a színnek hányad részét adja vissza). Amennyiben nem volt találat a háttér színét
    adja vissza. Ha elértük a rekurziós számnyi "pattogást" akkor feketét adunk vissza.

    Ezt egy rövid függvény követi; \texttt{rand\_square()} ami az x-y síkon a (-0.5 --- 0.5)x(-0.5 --- 0.5) területen 
    visszaad egy random vektort (z komponens mindig 0).

    Végezetül a \texttt{render()} függvény végigiterál a nézőportál minden pixelén
    bal fentről kezdve. A legbelső for ciklus azért kell, hogy ne olyan élesek, szögletesek legyenek
    az objektumok határai (itt használjuk fel a \texttt{rand\_square()} függvényt, hogy mindig 
    kicsit más irányba küldjük a sugarakat, és aztán kiátlagoljuk az eredményt). Elküldünk minden 
    pixelhez tartozó színértéket a \texttt{\_color\_divider()}-be ami kiszínezi, egy
    fájlba lementi az RGB értékeket. Amint megvagyunk egy képkockával bezárjuk azt a fájlt.

    \subsection{video\_render.c}
    Ez a fő fájl ahol végül maga a renderelés megtörténik. Kiírjuk a kis szöveget,
    a \texttt{printCaption()} függvénnyel. Utána bekérjük a 
    felhasználótól, hogy hány pixelt szeretne látni vízszintesen. Létrehozzuk a
    nézőportál és a renderelés többi paraméterét, majd ezeket berakjuk a \texttt{viewport\_creator()}-ba
    ami átírja a szükséges paraméterek értékét. Ezután megkérdezzük a felhasználót,
    hogy hány gömböt szeretne. Létrehozunk egy \texttt{sphere} dinamikus tömböt aminek a mérete
    eggyel több lesz mint a felhasználó által megadott érték, mivel a tömbben az első gömb
    (egy meghatározott paraméterű gömb) a földnek feleltethető meg. Közben ellenőrizzük, hogy
    sikerült-e létrehozni a dinamikus tömböt. Ha megvan a dinamikus tömb, akkor meghívjuk
    a \texttt{\_rand\_spheres()} függvényt, hogy a többi elemet feltöltse gömbökkel. Ezután a reflekciós
    számot is bekérjük a felhasználótól ("Milyen vilagosak legyenek a gombok?"). Végül pedig bekérjük
    a videó hosszát, és abból kiszámoljuk, hogy hány képkockát kell generáljunk (30 fps-en futnak a videók).
    Minden bekérésnél ellenőriztük, hogy a felhasználó által megadott adat formátuma
    helyes volt-e és, hogy a megfelelő határokon belül adta-e meg az értékeket. Amennyiben nem 
    hibaüzenetet küldünk, és várjuk, hogy új adatot adjon meg. A render elkezdése előtt csinálunk
    egy kis vizuális sávot ahol lehet követni, hogy hogy áll a program.

    Ezután egy for ciklussal elindulunk, és minden képkockához nyitunk egy új fájlt.
    Itt az \texttt{sprintf()} függvényt használjuk, hogy a fájlneveknek csak a "sorozatszáma"
    változzon. Ellenőrizzük, hogy sikerült-e megnyitni a fájlt. Ha nem kilépünk, ha igen
    minden kép elejére beírunk egy-két paramétert ami a ppm formátum miatt használatos.:
    \begin{lstlisting}[language=C]
        fprintf(fp, "P3\n%d %d\n255\n", image_width, image_height);
    \end{lstlisting}
    Utána meghívjuk a \texttt{render()} függvényt, a megfelelő paraméterekkel. A vizuális sávra
    kiírunk egy '/' jelet ha a program az előző kiíráshoz képest legalább 2 százalékot haladt előre.
    (Ez itt nem működne rövid videókra, de olyan rövidet nem adhat meg a felhasználó.)
    Ezután meghívjuk a \texttt{harm\_osc\_y()} függvényt és kicsit odébb rakjuk a gömböket.
    Ha az egész képgenerálás kész kiírjuk hogy Kész.
    Utána ffmpeg-gel összefűzzük a képkockákat videóvá, töröljük a képkockákat (ha a felhasználó 
    futás közben megszakítja a programot akkor nem törlődnek a képkockák, újabb teljes futásnál viszont
    már egyben kitörli a program a képkockákat.). Végül lejátsszuk a videót. Itt
    használtuk a \texttt{system()} parancsot, hogy el tudjuk végezni a fönt említett
    folyamatokat.
    Legutoljára pedig felszabadítjuk a dinamikusan allokált tömböt.

    Sok sikert és jó szórakozást a program próbálgatásához!








\end{document}