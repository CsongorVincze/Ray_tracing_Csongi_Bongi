\documentclass{article}

% --- PACKAGES ---
\usepackage[utf8]{inputenc} % Allows standard characters
\usepackage{geometry}       % Adjusts page margins
\usepackage{listings}       % ESSENTIAL: Allows you to format code blocks
\usepackage{xcolor}         % Adds color support for the code blocks
\usepackage{hyperref}       % Makes the Table of Contents clickable

% --- CODE BLOCK STYLING ---
% This sets up how your code will look (like a dark theme editor)
\lstset{
    backgroundcolor=\color{black!5},   % Light grey background
    basicstyle=\ttfamily\small,        % Typewriter font
    breaklines=true,                   % Break long lines automatically
    frame=single,                      % Adds a frame around the code
    keywordstyle=\color{blue},         % Keywords (if/else) in blue
    commentstyle=\color{green!50!black}% Comments in dark green
}

% --- TITLE PAGE DATA ---
\title{Fejlesztői dokumentáció}
\author{Vincze Csongor}
\date{\today}

% --- DOCUMENT BEGINS HERE ---
\begin{document}

% 1. Create Title Page
\maketitle

% 2. Create Table of Contents
\tableofcontents
\newpage

% 3. Main Content
\section{A program ismertetése, áttekintése}
Ez a program egy nagyon alapvető sugárkövetőt (ray tracer) implementál le.
A lényege, a virtuális kamerából (ahonnét mi a képet látjuk) sugarakat küld,
és ezeknek a sugaraknak a gömbökkel való ütközöését követi.
Miután a felhasználó megadja a megfelelő paramétereket a program elkezdi a képkockák
generálását. A képkockák generálásának előrehaladását közben a felhasználó egy 
folyamatjelző sávon követheti. Amint az összes képkocka generálása megtörtént
a szoftver összefűzi a képkockákat egy videóvá, és ezt el is indítja.

\section{Nyelv, használt csomagok, kiegészítők}
A teljes projekt C nyelvben íródott, az alapvető C könyvtárak felhasználásával,
minden külső csomag nélkül. A program nagy vonalakban a \url{https://raytracing.github.io/books/RayTracingInOneWeekend.html#overview}
dokumentációt követi (természetesen C nyelvre átírva).

\section{Az arhitektura áttekintése, a program kezelése}
A \texttt{video\_render.exe} futtatásakor a program bekéri a videó
elkészítéséhez szükéges adatokat. Ezek sorba:
\begin{enumerate}
    \item Milyen felbontást szeretnél? (szélesség pixelekben) (elfogadható értékek: $2^n$, ahol $n$ egész és $4 < n < 11$)
    \item Hány gömbot szeretnél? (ajánlott: 2-10)
    \item Milyen hosszú videót szeretnél? (a videó 30fps-en fut, 1-10 közötti egész szám elfogadott)
\end{enumerate}

Az első bemenet a kép vízszíntes pixelszámát adja meg (a képarány 16:9). Itt 1024-nél már jelentősen
lelassul a program. 256-nál viszont még elég alacsony lesz a készített videó minősége.
Érdemes lehet ezt az értéket 512-re állítani. Ezzel az adattal a program
már el tudja készíteni az ún. nézőportált (viewport), ami meghatározza, hogy mit, hogy fogunk látni. A többi paraméter
fix. A \texttt{viewport\_creator} függvény végzi ezt a folyamatot, és a \texttt{video\_render.c} hívja meg a \texttt{render.h}-ból.
A gömbök száma egészen 0-tól 50-ig terjedhet. Ennek ellenére nem ajánlott 10-nél
többet megadni mivel ez is jelentősen lelassítja a programot. A gömbökre van egy külön struktúra (sphere), egy ilyen tömböt hozunk
létre. A a videó készítés közben mozgatni fogjuk a gömböket. Mivel csak gömb alakú objektumokkat dolgozunk,
így érdemes ennek a tömbnek az elejére egy előre beállított nagy gömböt rakni, hogy
legyen egy földünk a videókhoz. Így valójában egyel több gömbbel operálunk mintamennyit bekértünk.
A harmadik bekérésnél hasonló
okokból kiindulva 5 körüli értéket érdemes megadni. Mivel konstans 30 fps-el dolgozunk így csak simán visszaszámoljuk,
hogy hány képkockát kell legeneráljunk.


\section{Fájlok és azok leírásaik}
A program egy fő .c fájlból és 10 header fájlból áll. A header fájlok főleg a program egyes részeihez
biztosítanak függvényeket. Minden fájl ugyan abba n a mappában van.

    \subsection{vec\_3.h}
    Mivel 3 dimenzióban dolgozunk szükségünk van vektoroperációkra.
    Ez a fájl biztosítja ezek meglétét. A fájlban minden függvény mellé fel van tüntetve, hogy mit csinál,
    így ezt nem részletezem itt. Ez a fájl tartalmazza a \texttt{vec\_3.h} struktúrát is ami, lényegében egy 3 dimenziós vektor típus.
    Ez a struktúra nagyon sokat könnyít a vekorok kezelésén.

    \subsection{ray.h}
    Ez a rész csupán a sugár (ray) struktúrát és egz sugárkövetőt tartalmazza.
    A sugár egy kiinduló pontból és egy irányvektorból áll. a sugárkövető pedig visszaadja
    egy t paraméter függvényében, hogy hol van a sugár.

    \subsection{intervals.h}
    Ez igazából csak megkönnyíti a program írását, átláthatóságát, ha valahol intervallumosan kell dolgozni.
    Például a a gömbök eltalálásánál használjuk ezt ki.
    

    \subsection{sphere.h}
    Ez a fájl a gömb struktúrát hozza létre. A gömb egy középpontból és egz sugárból áll.
    Ezután a \texttt{hit\_sphere} függvény következik ami, lényegileg eldönti, hogy az adott sugár eltalálta-e az adott gömböt.
    Ez a függvény egy bináris értéket ad vissza. Emellett kiszámolja, hogy hol történt a találat, milyen hosszú
    volt a sugár, és a találatnál a gömb normálvektorát. Ezeket elmenit
    egy pointerrel inputként megadott \texttt{hit\_rec} struktúrába.
    %itt ezt ki kell felyteni es csekkolni
    Ezt két függvény követi; az \texttt{\_array\_spheres} és a \texttt{\_rand\_spheres}. Előbbi egy vízszintes sorba rak le gömböket.
    Ez inkább a teszteléshez, paraméterek állításához használandó.
    Útóbbi pedig (bizonyos korlátok kötött) random paraméterekkel rakja le a gömböket.

    \subsection{hittable.h}
    Ez a header létrehoz egy \texttt{hit\_rec} struktúrát, a következő módon;

        \begin{lstlisting}[language=C]
        typedef struct{
            point_3 p;              // ebben taroljuk az eltalalt pontot
            vec_3 outward_normal;   // mindig kifele mutato norma
            vec_3 normal;           // ez a norma mindig a sugarral 
                                    // elenkezo iranyba mutat
            double t;               // mennyi "ido"-be telt a sugarnak 
                                    // eltalalni a pontot
            bool front_face;        // kivulrol jon-e a sugar
        } hit_rec;
        \end{lstlisting}

    Ezután létrehozom a \texttt{hit\_side} függvényt. A függvény lényege, hogy meghatározza,
    hogy a gömb melyik oldalán vagyunk. (A felhasználó által használt .exe fájl enélkül is
    működne mivel úgy vannak beállítva a paraméterek, hogy minden gömböt kívülről találjukn el.)

    \subsection{hit\_list.h}
    Ez a header csak egy függvényből áll, ez viszont egy nagyon hasznos függvény.
    a \texttt{which\_hit} Megnézi, hogy egy adott sugár melyik gömböket találja el
    (meghívja a \texttt{hit\_sphere} függvényt minden gömbre.), és a legközelebbi találat
    adatait lementi egy \texttt{hit\_rec} struktúrába. A függvény egyet ad vissza,
    ha sikerült eltalálni egy gömböt, nullát ha nem sikerült eltalálni semmit sem.

    \subsection{color.h}
    Először csinálunk egy color nevű típust ami egy hasommása a \texttt{vec\_3}
    stuktúrának. (Itt kihasználjuk azt, hogy egy RGB-vel megadott színnek pont három
    komponense van, csakúgy mint egy vektornak is.)
    Ez a fájl is egy függvényt tartalmaz. A \texttt{\_color\_divider} inputként egy
    színt és egy fájl pointert kap. A színt szétbontja megfelelő RGB formátumra,
    és beleírja a fájlba.

    \subsection{common\_headers.h}
    Ez igazából csak arra jó, hogy ne kelljen folyton az összes header fájlt cipelni,
    ebbe belerakjuk őket és ezt "icludoljuk". Emellett a program megnyitását követően
    felugró felirat kiírására itt tároljuk a függvényt. (A többi dolog ami még itt van
    nem olyan fontos.)

    \subsection{animation.h}
    Ez azért felelős, hogy valóban videót kapjunk és ne csak egymás után rakott
    ugyan olyan képeket.
    Két opciónk van. Az első a gömböket az y tengely mentén harmónikusan rezgeti
    (\texttt{harm\_osc\_y}). A másik pedig minden irányban valamilyen kis random
    értéket ad hozzá a gömbök középpontjának koordinátáihoz, így egyfajta véletlen
    séta szerűséget kapunk (\texttt{random\_walk}).

    \subsection{render.h}
    Itt először létrehozzuk a kamera és a  nézőportál (viewport) paramétereit, a \texttt{viewport\_creator}
    fügvénnyel. A fix képarányból és a kép szélességéből kiszámoljuk a 
    kép magasságát. Utána pedig a nézőportált (lényegileg a kiküldött sugaraknak ad egz korlátot
    hogy az egész térből mit lásson). Ezután kiszámoljuk a kis vektorokat amiket
    majd hozzáadogatunk a bal felső pixelhez, így jutunk el az összes pixelhez.
    Végül pedig kiszámoljuk a bal felső pixel (és a bal felső csúcs) koordinátáit.

    Ezután jön a \texttt{ray\_color} függvény. Ez egy rekurzív függvény ami először
    megnézi hogy az adott irányba indított sugár talált-e (meghívja a \texttt{which\_hit} függvényt)
    Ha volt találat akkor meghívja magát ujra (a rekurziós szám 20-ra van állítva)
    a gömb találati pontjáról a gömbtől elfelé
    random irányba mutató irányvektorral (itt a \texttt{vec\_3}-ból hívja meg a 
    \texttt{\_unit\_vec\_on\_hemisphere} függvényt), és a gömb adott pontjával
    (ezeket berakja egy \texttt{ray\_3 struktúrába}), és a végül
    visszakapott értéket megszorozza a \texttt{reflection\_number}-el (lényegileg az, hogy
    a színnek hányad részét adja vissza). Amennyiben nem volt találat a háttár színét
    adja vissza. Ha elertuk a rekurziós számnyi "pattogást" akkor feketét adunk vissza.

    Ezt egy rövid függvény követi; \texttt{rand\_square()} amit az x-y síkon a (-0.5 --- 0.5)x(-0.5 --- 0.5) területen 
    visszaad egy random vektort (z komponens mindig 0).

    Végezetül a render függvény végigiterál a nézőportál minden pixelén
    bal fentről kezdve. A legbelső for ciklus azért kell, hogy ne olyan élesek, szögletesek legyenek
    az objektumok határai (itt használjuk fel a \texttt{rand\_square()} függvényt, hogy mindig 
    kicsit más irányba küldjük a sugarakat, és aztán kiátlagoljuk az eredményt). Elküldünk minden 
    pixelhez tartozó színértéket a \texttt{\_color\_divider}-be ami kiszínezi, egy
    fájlba lementi az RGB értékeket. Amint megvagyunk egy képkockával bezárjuk azt a fájlt.

    %\subsection{video_render.c}
    %todo valami olyat mondtak h tobb .c file kell






\end{document}